#pragma once

#include <cstddef>
#include <cstdint>
#include <string>

// CONSTANT VALUES
static constexpr std::size_t MEM_SIZE = 4096;
static constexpr std::size_t REG_COUNT = 16;
static constexpr std::size_t SCREEN_W = 64;
static constexpr std::size_t SCREEN_H = 32;
static constexpr std::size_t STACK_DEPTH = 16;
static constexpr std::size_t KEYPAD_KEYS = 16;
static constexpr std::size_t FONTSET_SZ = 80;
static constexpr std::size_t BYTE_MAX = 0xFF;

static constexpr unsigned char chip8_fontset[80] = {
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};

class CHIP8
{
public:
    // User methods
    void loadROM(const std::string &);

    void initialize();
    void emulateCycle();

    // Debug methods
    void debugDisplay();

private:
    // Specifications
    uint16_t opcode_;
    uint8_t mem_[MEM_SIZE];
    uint8_t V_[REG_COUNT];
    uint16_t I_;
    uint16_t pc_;

    uint8_t gfx_[SCREEN_H * SCREEN_W];

    uint8_t sound_timer_;
    uint8_t delay_timer_;

    uint16_t stack_[STACK_DEPTH];
    uint16_t sp_;

    uint8_t key_[KEYPAD_KEYS];

    // Helper attributes
    bool drawF_;

    // Instruction set
    using instr = void (CHIP8::*)();

    static instr opcode_table_[16];
    static instr subTable8_[15];

    void handle0xxx();
    void handle1xxx();
    void handle2xxx();
    void handle3xxx();
    void handle4xxx();
    void handle5xxx();
    void handle6xxx();
    void handle7xxx();
    void handle8xxx();
    void handle9xxx();
    void handleAxxx();
    void handleBxxx();
    void handleCxxx();
    void handleDxxx();
    void handleExxx();
    void handleFxxx();

    // Behaviour
    void cpuNULL();
    void fetch();
    void execute();

    // Assignment based
    void setVxVy(const uint8_t &, const uint8_t &);

    // BCD based
    void bcd(const uint8_t &);

    // BitOp based
    void orVxVy(const uint8_t &, const uint8_t &);
    void andVxVy(const uint8_t &, const uint8_t &);
    void xorVxVy(const uint8_t &, const uint8_t &);
    void shrVx(const uint8_t &);
    void shlVx(const uint8_t &);

    // Conditional branching based
    void skipIfEqual(const uint8_t &, const uint8_t &);
    void skipIfNotEqual(const uint8_t &, const uint8_t &);

    // Display based
    void clearDisplay();
    void drawSprite();

    // Const based
    void setRegister(const uint8_t &, const uint8_t &);
    void addToRegister(const uint8_t &, const uint8_t &);

    // Flow based
    void returnFromSubroutine();
    void jumpToAddress(const uint16_t &);
    void jumpToAddressV0(const uint16_t &);
    void callSubroutine(const uint16_t &);

    // Math based
    void addVxVy(const uint8_t &, const uint8_t &);
    void subVxVy(const uint8_t &, const uint8_t &);
    void subnVxVy(const uint8_t &, const uint8_t &);

    // Memory based
    void setIndex(const uint16_t &);
    void addToIndex(const uint8_t &);
    void setSpriteToIndex(const uint8_t &);
    void writeToMemory(const uint8_t &);
    void loadFromMemory(const uint8_t &);

    // Rand based
    void setVxRandom(const uint8_t &, const uint8_t &);

    // Sound timer based
    void setST(const uint8_t &);

    // Delay timer based
    void getDT(const uint8_t &);
    void setDT(const uint8_t &);
};